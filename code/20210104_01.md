# Format 出现 FFFFFF

## 1. 问题现象

```c
#include <stdio.h>

void main()
{
    char c = 0x80;

    printf("0x%X\n", c);
}

```

输出结果：

```c
0xFFFFFF80
```

上面的例子是不是很奇怪，为什么会出现 FFFFFF？

## 2. 问题分析

### 2.1 基本概念

首先，在定义一个整型变量时，我们必须自已决定是否需要正负。如果这个量不会有负值，那么我们可以定义它为不带正负的类型。

在计算机内部，所有信息都是用二进制数串的形式表示的。整数通常都有正负之分，计算机中的整数分为无符号的和带符号的。

通常我们用最高的有效位来表示数的符号。0 表示正号、1 表示负号，这种正负号数字化的机内表示形式就称为“机器数”，而相应的机器外部用正负号表示的数称为“真值”。将一个真值表示成二进制字串的机器数的过程就称为编码。

带符号整数有原码、反码、补码等几种编码方式。原码即直接将真值转换为其相应的二进制形式，而反码和补码是对原码进行某种转换编码方式。正整数的原码、反码和补码都一样，负数的反码是对原码的除符号位外的其他位进行取反后的结果。而补码是在反码的末尾位加 1 后得到的结果，即：补码 = 反码 + 1。

**举例如下：**

|十进制|真值|反码|补码|
|:-:|:-:|:-:|:-:|
-0|`1000 0000`|`1111 1111`|`0000 0000`
-1|`1000 0001`|`1111 1110`|`1111 1111`
...|...|...|...
-127|`1111 1111`|`1000 0000`|`1000 0001`
-128|无|无|`1000 0000`

其中 `-128` 是特殊情况（8 位时 `-128` 是特例，16 位时 `-32768` 是特例）。

### 2.2 问题解释

回到问题本身，我们定义了 `char c = 0x80`，如果用十进制表示的话，相当于告诉计算机我们需要的是 `-128`。

C89 标准规定，short 和 char 会被自动提升为 int（整形化，类似地，float 也会自动提升为 double），这样做是为了便于编译器进行优化，使变量的长度尽可能一样，尽可能提升所产生代码的效率。

在 int 下，`-128`：

|-128||
|-|-|
|真值|`1000 0000 0000 0000 0000 0000 1000 0000`|
|反码|`1111 1111 1111 1111 1111 1111 0111 1111`|
|补码|`1111 1111 1111 1111 1111 1111 1000 0000`|

因此，打印出来就变成了 `0xFFFFFF80`。
