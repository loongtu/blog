# C 程序的内存布局

一个典型的 C 程序内存布局应该有以下几个部分：

- 代码段/文本段（Text segment）

- 初始化数据段（Initialized data segment or Data segment）

- 未初始化数据段（Uninitialized data segment or bss）

- 堆（Heap）

- 栈（Stack）

![image](./20220508_01_pic_001.jpg)

## 1. 详解

### 1.1 文本段（Text segment）

文本段又被称为代码段，这是由 CPU 执行的机器指令部分。

我们发现文本段是从最低地址开始分配的，那是因为，如果放在堆栈的后面，如果堆栈溢出overflow了，那么文本段就可能会被覆盖掉，造成不可预料的程序错误，因此为了避免这个问题，我们把文本段放在了最低位。

通常，文本段是可共享的，因此，对于同一个模块，我们只需要在文本段保留一个副本就够了。文本段通常是只读的，从而避免程序在意外情况下改变了其中的指令。

### 1.2 初始化数据段（Initialized data segment）

初始化的数据段，通常简称为数据段（Data segment），它包含由程序员初始化的全局变量和静态变量。

该段可以被进一步分为（初始化的）只读区域和（初始化的）可读写区域。

例如，全局变量 `char *string = "hello world"`，其字符串文本 "hello world" 存储在初始化只读区域，而指针变量存储在初始化读写区域。

例如：静态变量 `static int i = 10` 存储在数据段中，全局变量 `int i = 10` 也存储在数据段中。

### 1.3 未初始化数据段（Uninitialized data segment or BSS）

未初始化的数据段，通常称为 bss 段，是早期汇编程序操作符 block started by symbol 的缩写，包含所有初始化为零或在源代码中没有显式初始化的全局变量和静态变量。

在程序开始执行之前，内核将该段中的数据初始化为 0。

### 1.4 堆（Heap）

堆区（heap）是用于分配动态内存的段。

### 1.5 栈（Stack）

栈用来存储自动变量（automatic variables），以及每次调用函数时需要保存的信息。每次调用函数时，要返回的地址和调用方环境的某些信息（如某些计算机寄存器）都保存在栈中。然后，新调用的函数在栈上为其自动变量和临时变量分配空间。

## 2. 示例

```c
#include <stdio.h>

const int a1 = 0, a2 = 1;

int b1 = 0, b2 = 1;

int c1;
const int c2;

char *d1 = "hello", d2[] = "world";

int main()
{
    static int e1 = 1, e2 = 0, e3;

    printf("main: %p\n", main);

    printf("&a1: %p, &a2: %p\n", &a1, &a2);
    printf("&b1: %p, &b2: %p\n", &b1, &b2);
    printf("&c1: %p, &c2: %p\n", &c1, &c2);

    printf("d1: %p, &d1: %p\n", d1, &d1);
    printf("d2: %p, &d2: %p\n", d2, &d2);

    printf("&e1: %p, &e2: %p, &e3: %p\n", &e1, &e2, &e3);
}
```

```shell
[root@57b557746c5d c-test]# gcc main.c -o main; ./main 
main: 0x400596
&a1: 0x4006f8, &a2: 0x4006fc
&b1: 0x601048, &b2: 0x601028
&c1: 0x601058, &c2: 0x601054
d1: 0x400700, &d1: 0x601030
d2: 0x601038, &d2: 0x601038
&e1: 0x601040, &e2: 0x60104c, &e3: 0x601050
```

```shell
[root@57b557746c5d c-test]# gcc -c main.c; objdump -x -s -d main.o
...
SYMBOL TABLE:
0000000000000000 l    df *ABS*  0000000000000000 main.c
0000000000000000 l    d  .text  0000000000000000 .text
0000000000000000 l    d  .data  0000000000000000 .data
0000000000000000 l    d  .bss   0000000000000000 .bss
0000000000000000 l    d  .rodata        0000000000000000 .rodata
0000000000000008 l     O .bss   0000000000000004 e3.2370
0000000000000004 l     O .bss   0000000000000004 e2.2369
0000000000000018 l     O .data  0000000000000004 e1.2368
0000000000000000 l    d  .note.GNU-stack        0000000000000000 .note.GNU-stack
0000000000000000 l    d  .eh_frame      0000000000000000 .eh_frame
0000000000000000 l    d  .comment       0000000000000000 .comment
0000000000000000 g     O .rodata        0000000000000004 a1
0000000000000004 g     O .rodata        0000000000000004 a2
0000000000000000 g     O .bss   0000000000000004 b1
0000000000000000 g     O .data  0000000000000004 b2
0000000000000004       O *COM*  0000000000000004 c1
0000000000000004       O *COM*  0000000000000004 c2
0000000000000008 g     O .data  0000000000000008 d1
0000000000000010 g     O .data  0000000000000006 d2
0000000000000000 g     F .text  00000000000000bf main
0000000000000000         *UND*  0000000000000000 printf
```

|地址|内容|段|变量类型|
|-|-|-|-|
|0x601058	|c1	|	|未初始化的全局变量
|0x601054	|c2	|	|未初始化的全局常量
|0x601050	|e3	|bss	|未初始化的静态局部变量
|0x60104c	|e2	|bss	|初始化为 0 的静态局部变量
|0x601048	|b1	|bss	|初始化为 0 的全局变量
|0x601044	|对齐
|0x601040	|e1	|data	|初始化不为 0 的静态局部变量
|0x601038	|d2	|data	|初始化不为空的指针变量
|0x601030	|d1	|data	|初始化不为空的指针变量
|0x60102c	|对齐		
|0x601028	|b2	|data	|初始化不为 0 的全局变量
|...		|	
|0x400704	|'o' 		
|0x400703	|'l' 		
|0x400702	|'l' 		
|0x400701	|'e' 		
|0x400700	|'h'|rodata	|d1 指向的字符串常量
|0x4006fc	|a2	|rodata	|初始化不为 0 的全局常量
|0x4006f8	|a1	|rodata	|初始化为 0 的全局常量
|...		|	
|0x400596	|main|	text	|函数地址

备注：

- 初始化为 0 或不为 0 的全局常量 a1 和 a2 放在 rodata 段。

- 字符串常量或者字符串字面量 "hello" 放在 rodata 段。

- 初始化不为 0 的全局变量 b2、d1、d2 和局部静态变量 e1 放在 data 段。

- 初始化为 0 的全局变量 b1 和局部静态变量 e2 放在 bss 段，认为是未初始化的，这是编译器的优化，因为 bss 段 不占磁盘空间。

- 未初始化的局部静态变量 e3 放在 bss 段。

- 为初始化的全局常量 c2 和全局变量 c1 放在 COM 块，这和编译器的实现有关，可以简单地认为也放在了 bss 段。


