# interview

## 1. 关键字 static 的作用是什么？

**static 修饰全局变量**

静态全局变量和其他全局变量都存储在 .data 段（已初始化）或者 .bss 段（未初始化）内，但是静态全局变量只在定义它的源文件内有效，其他源文件无法访问。

**static 修饰局部变量**

静态局部变量与普通局部变量的区别：

- 静态局部变量存储在静态存储区 .data 或 .bss 段内，在程序整个运行期间都不释放。
  而普通局部变量存储在栈上，函数调用结束后立即释放。

- 静态局部变量是在编译时赋初值的，即只赋值一次，在程序运行时它已有初值。以后每次调用函数时不再重新赋初值而只是保留上次函数调用结束时的值。
  而对普通局部变量赋初值，是在函数调用时进行的，每调用一次函数重新赋一次初值。

- 如在定义局部变量时不赋初值的话，则对静态局部变量来说，编译时自动赋初值 0。而对普通局部变量来说，如果不赋初值则它的值是一个不确定的值。

- 虽然静态局部变量在函数调用结束后仍然存在，但其他函数不能引用它。

**static 修饰函数**

静态函数只是在声明他的文件当中可见，不能被其他文件所用，因此 static 可以解决不同源文件中函数同名的问题。

## 2. 如何防止头文件被重复引用？

**条件编译语句**

```c
#ifndef _TEST_H_
#define _TEST_H_

#endif
```

**#pragma once 语句**

## 3. #include <file.h> 与 #include "file.h" 的区别？

搜索路径不同。

- ""：先从当前目录找，如果没有再到编译器指定的目录去找。

- <>：让编译器只到指定的目录去找。

## 4. 关于程序的内存分配，一个由 C/C++ 编译的程序占用的内存分为哪几个部分，分别存放哪类数据，详细说说。如全局变量和局部变量在内存中都存放在哪里？

分为 text 段、rodata、data 段、bss 段，以及堆栈。

- text 段存放由 CPU 执行的机器指定部分。

- rodata 段存放只读变量和字符串常量。

- data 段存放已经初始化了的全局变量和静态局部变量。

- bss 段存放未初始化的全局变量和静态局部变量，这些变量在程序运行之前不需要占用存储器的空间。

- 堆内存只在程序运行时出现，一般由程序员分配和释放。

- 栈内存只在程序运行时出现，在函数内部使用的变量，函数的参数以及返回值将使用栈空间，栈空间由编译器自动分配和释放。

## 5. 局部变量能否和全局变量重名？如果在函数内使用这个变量，究竟是用的哪一个呢？

可以重名，用的是局部变量。

## 6. 如何引用一个已经在别的 .c 文件里定义过的全局变量？

用 extern 关键字方式，用引用头文件的方式。

## 7. 说一下 C 语言的编译过程，依次是哪几个步骤？预编译期间主要做些什么工作？被调用的函数未声明，在哪个阶段可以发现？如果声明了但是没定义，在哪个阶段可以发现？

 **C语言编译过程分成四个步骤**

- 预处理，由 .c 文件到 .i 文件，主要处理源文件中以 # 开始的预编译指令。

- 编译，由 .i 文件到 .s 文件，就是把预处理完的文件进行一系列词法分析、语法分析、语义分析及优化后生成相应的汇编代码文件。

- 汇编，由 .s 文件到 .o 文件，就是将汇编代码转变成机器可以执行的指令。

- 链接，由 .o 文件到可执行文件。

**预编译期间主要工作**

预处理过程主要处理源文件中以 # 开始的预编译指令。比如 #include、#define 等。主要处理规则如下：

- 将所有的 #define 删除，并且展开所有的宏定义。

- 处理所有的条件预编译指令，如 #if、#elif、#else、#ifdef、#ifndef、#endif 等。

- 处理 #include，将被包含的文件插入到该指令的位置。

- 删除所有注释。

- 添加行号和文件名标识，以便于编译时编译器产生调试用的行号信息及用于编译时产生编译错误或警告时能够显示行号。

- 保留 #pragma 编译器指令，因为编译器需要使用它们。

“函数未声明”错误发生在编译阶段，“函数未定义”错误发生在链接阶段。

## 8. 关键字 const 是什么含义？下面的声明都是什么意思？

```c
const int a;
int const a;
const int *a;
int *const a;
```

const 用来定义常量，表示这个常量不可以被修改。

声明的意思分别为：

- 定义常量 a，a 不可被修改。

- 同 1。

- 定义常量指针 a，不能通过这个指针改变变量的值。

- 定义指针常量 a，指针本身是个常量，不能再指向其他的地址。

## 9. 结构体 struct 与联合 union 有什么区别？

-  struct 各成员各自拥有自己的内存，各自使用互不干涉，同时存在的，遵循内存对齐原则。一个struct变量的总长度等于所有成员的长度之和。

-  union 各成员共用一块内存空间，并且同时只有一个成员可以得到这块内存的使用权（对该内存的读写），各变量共用一个内存首地址。因而，联合体比结构体更节约内存。一个union变量的总长度至少能容纳最大的成员变量，而且要满足是所有成员变量类型大小的整数倍。

## 10. 嵌入式系统总是要用户对变量或寄存器进行位操作。给定一个增型变量 a，写两个函数，第一个设置 a 的 bit 3，第二个清除 a 的 bit 3。在以上两个操作中，要保持其他位不变，用 #define 和 bit masks 操作。

```c
#include <stdio.h>

#define BIT3_MASK (1 << 3)

int set_bit3(int a)
{
    a |= BIT3_MASK;
    return a;
}

int clear_bit3(int a)
{
    a &= (~BIT3_MASK);
    return a;
}

int main()
{
    int a1 = 0;
    a1 = set_bit3(a1);
    printf("0x%X\n", a1);

    int a2 = 0xFFFFFFFF;
    a2 = clear_bit3(a2);
    printf("0x%X\n", a2);
}
```

```shell
[root@57b557746c5d c-test]# gcc main.c -o main; ./main
0x8
0xFFFFFFF7
```

## 11. A.c 和 B.c 两个文件中使用了两个相同名字的 static 变量，编译的时候会不会有问题？这两个变量会保存到哪里（堆、栈还是其他）？

不会有问题，保存在静态存储区 .data 或 .bss 段内。

## 12. 64 位机，设有以下说明和定义：

```c
typedef union {int k[4]; char c;} DATE;
struct data {int cat; DATE cow; double dog;};
DATE max;
```

则语句 `printf("%d", sizeof(struct data) + sizeof(max));` 的执行结果是？

struct data 按 double（8 字节）对齐。cat 4 字节，DATE 占用 16 字节，对齐需要 4 字节，再加上 double 8 字节，struct data 总共 32 字节。

因此执行结果是 32 + 16 = 48。

## 13. 以下 3 种写法有什么区别

```c
char *const p;
char const *p;
const char *p;
```

- 定义指针常量 p，指针本身是个常量，不能再指向其他的地址。

- 定义常量指针 p，不能通过这个指针改变变量的值。

- 同 2。

## 14. 请问以下代码有什么问题？

```c
#include <stdio.h>
#include <string.h>

int main()
{
    char a;
    char *str = &a;

    strcpy(str, "hello");
    printf(str);

    return 0;
}
```

Segmentation fault (core dumped)

strcpy 时，超出栈的范围了，return 时会报 Segmentation fault。
