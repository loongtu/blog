# interview

[a](./20220508_02.md##-C)

## C

### 1.1 关键字 static 的作用是什么？

**static 修饰全局变量**

静态全局变量和其他全局变量都存储在 .data 段（已初始化）或者 .bss 段（未初始化）内，但是静态全局变量只在定义它的源文件内有效，其他源文件无法访问。

**static 修饰局部变量**

静态局部变量与普通局部变量的区别：

- 静态局部变量存储在静态存储区 .data 或 .bss 段内，在程序整个运行期间都不释放。
  而普通局部变量存储在栈上，函数调用结束后立即释放。

- 静态局部变量是在编译时赋初值的，即只赋值一次，在程序运行时它已有初值。以后每次调用函数时不再重新赋初值而只是保留上次函数调用结束时的值。
  而对普通局部变量赋初值，是在函数调用时进行的，每调用一次函数重新赋一次初值。

- 如在定义局部变量时不赋初值的话，则对静态局部变量来说，编译时自动赋初值 0。而对普通局部变量来说，如果不赋初值则它的值是一个不确定的值。

- 虽然静态局部变量在函数调用结束后仍然存在，但其他函数不能引用它。

**static 修饰函数**

静态函数只是在声明他的文件当中可见，不能被其他文件所用，因此 static 可以解决不同源文件中函数同名的问题。

### 1.2 如何防止头文件被重复引用？

**条件编译语句**

```c
#ifndef _TEST_H_
#define _TEST_H_

#endif
```

**#pragma once 语句**

### 1.3 #include <file.h> 与 #include "file.h" 的区别？

搜索路径不同。

- ""：先从当前目录找，如果没有再到编译器指定的目录去找。

- <>：让编译器只到指定的目录去找。

### 1.4 关于程序的内存分配，一个由 C/C++ 编译的程序占用的内存分为哪几个部分，分别存放哪类数据，详细说说。如全局变量和局部变量在内存中都存放在哪里？

分为 text 段、rodata、data 段、bss 段，以及堆栈。

- text 段存放由 CPU 执行的机器指定部分。

- rodata 段存放只读变量和字符串常量。

- data 段存放已经初始化了的全局变量和静态局部变量。

- bss 段存放未初始化的全局变量和静态局部变量，这些变量在程序运行之前不需要占用存储器的空间。

- 堆内存只在程序运行时出现，一般由程序员分配和释放。

- 栈内存只在程序运行时出现，在函数内部使用的变量，函数的参数以及返回值将使用栈空间，栈空间由编译器自动分配和释放。

### 1.5 局部变量能否和全局变量重名？如果在函数内使用这个变量，究竟是用的哪一个呢？

可以重名，用的是局部变量。

### 1.6 如何引用一个已经在别的 .c 文件里定义过的全局变量？

用 extern 关键字方式，用引用头文件的方式。

### 1.7 说一下 C 语言的编译过程，依次是哪几个步骤？预编译期间主要做些什么工作？被调用的函数未声明，在哪个阶段可以发现？如果声明了但是没定义，在哪个阶段可以发现？

 **C语言编译过程分成四个步骤**

- 预处理，由 .c 文件到 .i 文件，主要处理源文件中以 # 开始的预编译指令。

- 编译，由 .i 文件到 .s 文件，就是把预处理完的文件进行一系列词法分析、语法分析、语义分析及优化后生成相应的汇编代码文件。

- 汇编，由 .s 文件到 .o 文件，就是将汇编代码转变成机器可以执行的指令。

- 链接，由 .o 文件到可执行文件。

**预编译期间主要工作**

预处理过程主要处理源文件中以 # 开始的预编译指令。比如 #include、#define 等。主要处理规则如下：

- 将所有的 #define 删除，并且展开所有的宏定义。

- 处理所有的条件预编译指令，如 #if、#elif、#else、#ifdef、#ifndef、#endif 等。

- 处理 #include，将被包含的文件插入到该指令的位置。

- 删除所有注释。

- 添加行号和文件名标识，以便于编译时编译器产生调试用的行号信息及用于编译时产生编译错误或警告时能够显示行号。

- 保留 #pragma 编译器指令，因为编译器需要使用它们。


